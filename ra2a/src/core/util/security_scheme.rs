use serde::{Deserialize, Serialize};
use std::collections::HashMap;

/// Defines a security scheme that can be used by the operations.
/// Supported schemes are HTTP authentication, an API key (either as a
/// header or as a query parameter), OAuth2's common flows (implicit, password,
/// application and access code) as defined in RFC6749, and OpenID Connect Discovery.
#[derive(Clone, Serialize, Deserialize, PartialEq)]
#[cfg_attr(feature = "grpc", derive(prost::Message))]
#[cfg_attr(not(feature = "grpc"), derive(Debug))]
pub struct SecurityScheme {
    #[serde(flatten)]
    #[cfg_attr(feature = "grpc", prost(oneof = "Scheme", tags = "1, 2, 3, 4, 5"))]
    pub scheme: Option<Scheme>,
}

#[allow(clippy::large_enum_variant)]
#[derive(Clone, Serialize, Deserialize, PartialEq)]
#[serde(tag = "type")]
#[cfg_attr(feature = "grpc", derive(prost::Oneof))]
#[cfg_attr(not(feature = "grpc"), derive(Debug))]
pub enum Scheme {
    #[serde(rename = "apiKey")]
    #[cfg_attr(feature = "grpc", prost(message, tag = "1"))]
    APIKey(APIKeySecurityScheme),

    #[serde(rename = "http")]
    #[cfg_attr(feature = "grpc", prost(message, tag = "2"))]
    HTTPAuth(HTTPAuthSecurityScheme),

    #[serde(rename = "oauth2")]
    #[cfg_attr(feature = "grpc", prost(message, tag = "3"))]
    OAuth2(OAuth2SecurityScheme),

    #[serde(rename = "openIdConnect")]
    #[cfg_attr(feature = "grpc", prost(message, tag = "4"))]
    OpenIDConnect(OpenIDConnectSecurityScheme),

    #[serde(rename = "mutualTls")]
    #[cfg_attr(feature = "grpc", prost(message, tag = "5"))]
    MutualTLS(MutualTLSSecurityScheme),
}

#[derive(Clone, Serialize, Deserialize, PartialEq)]
#[cfg_attr(feature = "grpc", derive(prost::Message))]
#[cfg_attr(not(feature = "grpc"), derive(Debug))]
pub struct APIKeySecurityScheme {
    /// A short description for security scheme. CommonMark syntax MAY be
    /// used for rich text representation.
    #[serde(default, skip_serializing_if = "String::is_empty")]
    #[cfg_attr(feature = "grpc", prost(string, tag = "1"))]
    pub description: String,

    /// The location of the API key. Valid values are "query", "header" or
    /// "cookie".
    #[serde(rename = "in")]
    #[serde(default, skip_serializing_if = "String::is_empty")]
    #[cfg_attr(feature = "grpc", prost(string, tag = "2"))]
    pub location: String,

    /// The name of the header, query or cookie parameter to be used.
    #[serde(default, skip_serializing_if = "String::is_empty")]
    #[cfg_attr(feature = "grpc", prost(string, tag = "3"))]
    pub name: String,
}

#[derive(Clone, Serialize, Deserialize, PartialEq)]
#[serde(rename_all = "camelCase")]
#[cfg_attr(feature = "grpc", derive(prost::Message))]
#[cfg_attr(not(feature = "grpc"), derive(Debug))]
pub struct HTTPAuthSecurityScheme {
    /// A short description for security scheme. CommonMark syntax MAY be
    /// used for rich text representation.
    #[serde(default, skip_serializing_if = "String::is_empty")]
    #[cfg_attr(feature = "grpc", prost(string, tag = "1"))]
    pub description: String,

    /// The name of the HTTP Authorization scheme to be used in the
    /// Authorization header as defined in RFC7235. The values used SHOULD
    /// be registered in the IANA Authentication Scheme registry.
    #[serde(default, skip_serializing_if = "String::is_empty")]
    #[cfg_attr(feature = "grpc", prost(string, tag = "2"))]
    pub scheme: String,

    /// A hint to the client to identify how the bearer token is formatted.
    /// Bearer tokens are usually generated by an authorization server, so
    /// this information is primarily for documentation purposes.
    #[serde(default, skip_serializing_if = "String::is_empty")]
    #[cfg_attr(feature = "grpc", prost(string, tag = "3"))]
    pub bearer_format: String,
}

#[derive(Clone, Serialize, Deserialize, PartialEq)]
#[serde(rename_all = "camelCase")]
#[cfg_attr(feature = "grpc", derive(prost::Message))]
#[cfg_attr(not(feature = "grpc"), derive(Debug))]
pub struct OAuth2SecurityScheme {
    /// A short description for security scheme. CommonMark syntax MAY be
    /// used for rich text representation.
    #[serde(default, skip_serializing_if = "String::is_empty")]
    #[cfg_attr(feature = "grpc", prost(string, tag = "1"))]
    pub description: String,

    /// An object containing configuration information for the flow types
    /// supported.
    #[cfg_attr(feature = "grpc", prost(message, tag = "2"))]
    pub flows: Option<OAuth2Flows>,

    /// URL to the oauth2 authorization server metadata
    /// [RFC8414](https://datatracker.ietf.org/doc/html/rfc8414). TLS is required.
    #[serde(default, skip_serializing_if = "String::is_empty")]
    #[cfg_attr(feature = "grpc", prost(string, tag = "3"))]
    pub oauth2_metadata_url: String,
}

#[derive(Clone, Serialize, Deserialize, PartialEq)]
#[serde(rename_all = "camelCase")]
#[cfg_attr(feature = "grpc", derive(prost::Message))]
#[cfg_attr(not(feature = "grpc"), derive(Debug))]
pub struct OpenIDConnectSecurityScheme {
    /// A short description for security scheme. CommonMark syntax MAY be
    /// used for rich text representation.
    #[serde(default, skip_serializing_if = "String::is_empty")]
    #[cfg_attr(feature = "grpc", prost(string, tag = "1"))]
    pub description: String,

    /// OpenId Connect URL to discover OAuth2 configuration values. This
    /// MUST be in the form of a URL.
    #[serde(default, skip_serializing_if = "String::is_empty")]
    #[cfg_attr(feature = "grpc", prost(string, tag = "2"))]
    pub open_id_connect_url: String,
}

#[derive(Clone, Serialize, Deserialize, PartialEq)]
#[serde(rename_all = "camelCase")]
#[cfg_attr(feature = "grpc", derive(prost::Message))]
#[cfg_attr(not(feature = "grpc"), derive(Debug))]
pub struct MutualTLSSecurityScheme {
    /// A short description for security scheme. CommonMark syntax MAY be
    /// used for rich text representation.
    #[serde(default, skip_serializing_if = "String::is_empty")]
    #[cfg_attr(feature = "grpc", prost(string, tag = "1"))]
    pub description: String,
}

#[derive(Clone, Serialize, Deserialize, PartialEq)]
#[cfg_attr(feature = "grpc", derive(prost::Message))]
#[cfg_attr(not(feature = "grpc"), derive(Debug))]
pub struct OAuth2Flows {
    #[serde(flatten)]
    #[cfg_attr(feature = "grpc", prost(oneof = "Flow", tags = "1, 2, 3, 4"))]
    pub flow: Option<Flow>,
}

#[derive(Clone, Serialize, Deserialize, PartialEq)]
#[serde(tag = "type")]
#[cfg_attr(feature = "grpc", derive(prost::Oneof))]
#[cfg_attr(not(feature = "grpc"), derive(Debug))]
pub enum Flow {
    #[cfg_attr(feature = "grpc", prost(message, tag = "1"))]
    AuthorizationCode(AuthorizationCodeOAuth2Flow),

    #[cfg_attr(feature = "grpc", prost(message, tag = "2"))]
    ClientCredentials(ClientCredentialsOAuth2Flow),

    #[cfg_attr(feature = "grpc", prost(message, tag = "3"))]
    Implicit(ImplicitOAuth2Flow),

    #[cfg_attr(feature = "grpc", prost(message, tag = "4"))]
    Password(PasswordOAuth2Flow),
}

#[derive(Clone, Serialize, Deserialize, PartialEq)]
#[serde(rename_all = "camelCase")]
#[cfg_attr(feature = "grpc", derive(prost::Message))]
#[cfg_attr(not(feature = "grpc"), derive(Debug))]
pub struct ImplicitOAuth2Flow {
    /// The authorization URL to be used for this flow. This MUST be in the
    /// form of a URL.
    #[cfg_attr(feature = "grpc", prost(string, tag = "1"))]
    pub authorization_url: String,
    /// The URL to be used for obtaining refresh tokens. This MUST be in the
    /// form of a URL.
    #[cfg_attr(feature = "grpc", prost(string, tag = "2"))]
    pub refresh_url: String,
    /// The available scopes for the OAuth2 security scheme. A map between the
    /// scope name and a short description for it. The map MAY be empty.
    #[cfg_attr(feature = "grpc", prost(map = "string,string", tag = "3"))]
    pub scopes: HashMap<String, String>,
}

#[derive(Clone, Serialize, Deserialize, PartialEq)]
#[serde(rename_all = "camelCase")]
#[cfg_attr(feature = "grpc", derive(prost::Message))]
#[cfg_attr(not(feature = "grpc"), derive(Debug))]
pub struct PasswordOAuth2Flow {
    /// The token URL to be used for this flow. This MUST be in the form of a
    /// URL.
    #[cfg_attr(feature = "grpc", prost(string, tag = "1"))]
    pub token_url: String,

    /// The URL to be used for obtaining refresh tokens. This MUST be in the
    /// form of a URL.
    #[cfg_attr(feature = "grpc", prost(string, tag = "2"))]
    pub refresh_url: String,

    /// The available scopes for the OAuth2 security scheme. A map between the
    /// scope name and a short description for it. The map MAY be empty.
    #[cfg_attr(feature = "grpc", prost(map = "string,string", tag = "3"))]
    pub scopes: HashMap<String, String>,
}
#[derive(Clone, Serialize, Deserialize, PartialEq)]
#[serde(rename_all = "camelCase")]
#[cfg_attr(feature = "grpc", derive(prost::Message))]
#[cfg_attr(not(feature = "grpc"), derive(Debug))]
pub struct ClientCredentialsOAuth2Flow {
    /// The token URL to be used for this flow. This MUST be in the form of a
    /// URL.
    #[cfg_attr(feature = "grpc", prost(string, tag = "1"))]
    pub token_url: String,

    /// The URL to be used for obtaining refresh tokens. This MUST be in the
    /// form of a URL.
    #[cfg_attr(feature = "grpc", prost(string, tag = "2"))]
    pub refresh_url: String,

    /// The available scopes for the OAuth2 security scheme. A map between the
    /// scope name and a short description for it. The map MAY be empty.
    #[cfg_attr(feature = "grpc", prost(map = "string,string", tag = "3"))]
    pub scopes: HashMap<String, String>,
}

#[derive(Clone, Serialize, Deserialize, PartialEq)]
#[serde(rename_all = "camelCase")]
#[cfg_attr(feature = "grpc", derive(prost::Message))]
#[cfg_attr(not(feature = "grpc"), derive(Debug))]
pub struct AuthorizationCodeOAuth2Flow {
    /// The authorization URL to be used for this flow. This MUST be in the
    /// form of a URL.
    #[cfg_attr(feature = "grpc", prost(string, tag = "1"))]
    pub authorization_url: String,

    /// The token URL to be used for this flow. This MUST be in the form of a
    /// URL.
    #[cfg_attr(feature = "grpc", prost(string, tag = "2"))]
    pub token_url: String,

    /// The URL to be used for obtaining refresh tokens. This MUST be in the
    /// form of a URL.
    #[cfg_attr(feature = "grpc", prost(string, tag = "3"))]
    pub refresh_url: String,

    /// The available scopes for the OAuth2 security scheme. A map between the
    /// scope name and a short description for it. The map MAY be empty.
    #[cfg_attr(feature = "grpc", prost(map = "string,string", tag = "4"))]
    pub scopes: HashMap<String, String>,
}

impl SecurityScheme {
    pub fn open_id_connect(
        open_id_connect_url: impl Into<String>,
        description: Option<impl Into<String>>,
    ) -> Self {
        SecurityScheme {
            scheme: Some(Scheme::OpenIDConnect(OpenIDConnectSecurityScheme {
                open_id_connect_url: open_id_connect_url.into(),
                description: description.map_or_else(String::new, Into::into),
            })),
        }
    }
}
